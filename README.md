

































СОДЕРЖАНИЕ 
 
ВВЕДЕНИЕ ............................................................................................................ 5 
1 Организация деятельности автомобильной компании .................................... 7 2 Постановка задачи на разработку программного средства для 
автомобильной компании ................................................................................ 18 3 Описание метода ранга ..................................................................................... 20 
4	МОДЕЛИ ПРЕДСТАВЛЕНИЯ СИСТЕМЫ ДЛЯ АВТОМОБИЛЬНОЙ 
КОМПАНИИ И ЕЕ ОПИСАНИЕ .................................................................... 22 
4.1	Спецификация вариантов использования системы для выбора рациональной структуры системы методом экспертных оценок ................. 22 
4.2	Описание диаграммы последовательности процесса авторизации ....... 23 
4.3	Описание диаграммы состояний .............................................................. 25 
4.4	Структура хранимых данных рейтингового агентства .......................... 26       4.5 Описание диаграммы классов программного средства для выбора рациональной структуры системы методом экспертных оценок ............... 28 5 Обоснование выбора программных средств разработки ............................. 31 6 Описание архитектуры «клиент-сервер» ...................................................... 34 
7	ОПИСАНИЕ АЛГОРИТМОВ, РЕАЛИЗУЮЩИХ БИЗНЕС-ЛОГИКУ 
СЕРВЕРНОЙ ЧАСТИ ПРОЕКТИРУЕМОЙ СИСТЕМЫ ............................. 36 
7.1	Схема алгоритма решения задачи статическим методом ...................... 36 
7.2	Схема алгоритма клиент-серверного взаимодействия ........................... 36 
7.3	Схема алгоритма предоставления статистической информации об 
автомобилях ...................................................................................................... 37 
8	Руководство по развертыванию системы ....................................................... 40 
9	Руководство пользователя ............................................................................... 42 
10	 Контрольный пример ...................................................................................... 58 
10.1	Расчет статического метода в условиях неопределенности вручную .. 58 
10.2	Использование  статического метода в условиях неопределенности в 
приложении ....................................................................................................... 59 
Заключение ........................................................................................................... 61 
Список использованных источников .................................................................. 62 Приложение а (обязательное) .............................................................................. 63 Приложение Б (обязательное) Листинг кода с коментариями ......................... 66 
  	 



























 
ВВЕДЕНИЕ
В настоящее время невозможно представить работу практически любых видов деятельности без автоматизации. Она необходима для ускорения сложных операций, в том числе расчетов. Автоматизация исключает человеческий фактор, позволяет контролировать выполнение трудовых функций всего предприятия. 
Проводить автоматизацию процессов следует для того, чтобы уберечь свою фирмы от лишних расходов. Некоторые руководители небольших фирм предпочитают справлять силами и умениями своих сотрудников. Но приобрести определенное программное обеспечение доступно многим, расходы на него быстро окупаются. Фирма в дальнейшем получает только прибыль. 
В современном мире каждый человек пытается найти более удобные пути решения бытовых проблем. Это связанно с недостаточным количеством времени, чрезмерной утомляемости в процессе рабочего дня и массой других причин. Одной из реализации упрощения является покупка автомобиля, так как это повысит эффективность комфорт при передвижении, поможет экономить массу свободного времени и быть независимым от общественного транспорта. 
В связи с этим существует огромное количество различных магазинов автомобилей, которые изобилуют автомобилями на любой вкус: различных марок, типов салона, оснащения, марок, ценовых категорий. 
И поэтому для каждого из таких магазинов было бы очень выгодно иметь специально разработанное ПО, помогающее оптимизировать множество процессов: предоставить доступный интерфейс пользователям, облегчить выполнение базовых задач и освободить от рутинной «бумажной» работы своих сотрудников, вести надёжный контроль и предоставление информации для начальства.  
Целью данного курсового проекта является повышение уровня автоматизации информационных систем деятельности автомобильного салона с ориентацией на качество и скорость обслуживания клиента путем разработки программного обеспечения. 
Для решения заданной цели необходимо выполнить следующие задачи: 
–	изучить реальную деятельность автосалона; 
–	проанализировать рынок; 
–	проанализировать информационную модель представления данных; 
–	изучить возможности использования баз данных, а также возможности СУБД; 
–	реализовать функционал для сервера, выполняющий стандартные операции с данными; 
–	разработать ПО, способное поддерживать эффективное выполнение основных функций.  
Для достижения поставленных задач необходимо следующее: 
–	исследовать предметную область курсового проекта; 
–	найти требуемые методы решения постановки задач; 
–	выполнить полное моделирование разрабатываемой системы; 
–	создать пользовательский интерфейс и функционал; 
–	уменьшить процент отказа в работе программы методом добавления проверок, фильтрации и одобрения поступающей информации. 
Актуальность курсовой работы обусловлена необходимостью автоматизации бизнес-процессов автомобильного салона или же хранения информации, так как это значительно облегчит и ускорит работу, увеличит эффективность деятельности компании. Однако перед внедрением стоит оценить целесообразность того или иного действия.  
Разработанный проект по автоматизации работы автомобильного салона позволит предоставить необходимый функционал для выполнения базовых функций работы с автосалоном, увеличить производительность и быстродействие работников автосалона. 
 	 





1  ОРГАНИЗАЦИЯ ДЕЯТЕЛЬНОСТИ АВТОМОБИЛЬНОЙ КОМПАНИИ 
1.1 Общие понятия и термины 
 
Статистические методы – научные методы описания и изучения массовых явлений, допускающих количественное (численное) выражение. 
Транспорт – одна из важнейших отраслей хозяйства, выполняющая функцию своеобразной кровеносной системы в сложном организме страны. Он не только обеспечивает потребности хозяйства и населения в перевозках, но вместе с городами образует «каркас» территории, является крупнейшей составной частью инфраструктуры, служит материально-технической базой формирования и развития территориального разделения труда, оказывает существенное влияние на динамичность и эффективность социальноэкономического развития отдельных регионов и страны в целом.  
Помимо тех неоспоримых удобств, которые легковой автомобиль создает в жизни человека, очевидно общественное значение массового пользования личными автомобилями: увеличивается скорость сообщения при поездках; сокращается число штатных водителей; облегчается доставка городского населения в места массового отдыха, на работу и т. д. 
Современный пассажирский транспорт обеспечивает перевозки людей, их ручной клади и багажа. Для пассажиров пользование транспортом связано, прежде всего, с экономией времени и сил, затрачиваемых на передвижение. Автомобильный транспорт как один из видов наземного транспорта получил наибольшее распространение и занимает ведущее положение в перевозках пассажиров, грузов, товаров на различные расстояния. Учитывая неослабевающий спрос на покупку новых и бывших в эксплуатации автомобилей, по всей стране сегодня появляются автосалоны, в которых предлагают совершить покупку комфортно и выгодно.  
Автосалон представляет собой место показа, хранения и предоставления информации об автомобилях. Иногда автосалоном называют помещение, в котором проходят подобные показы. Основным видом деятельности автосалона является реализация автомобилей. 
Главная задача автосалона – торговля автомобилями. Соответственно бизнес-процессы автосалона и магазина в основном схожи. Автосалон – это организация, у которой имеются: печать, графическая символика, расчетный и иные счета в рублях и других валютах. Организация имеет право от своего имени заключать любые, законные сделки.  
 
1.2 Стратегическая карта 
 
Стратегическая карта — это диаграмма, которая используется для документирования главных стратегических целей, поставленных перед организацией или руководством организации. Очень важным для создания связной и реалистичной стратегической карты является реальное понимание иерархических внутренних взаимосвязей между используемыми перспективами. Каждая перспектива содержит одну или несколько стратегических целей, которые в свою очередь связаны с одним или несколькими показателями эффективности и их целевыми значениями. Расположение стратегических целей на стратегической карте выбрано не случайно и служит наглядному представлению взаимосвязей между выбранными заголовками перспектив. 
Цель области «финансы» – это рост прибыли компании, которая может быть достигнута путем расширения клиентской базы и при помощи роста производительности труда. Показатели, по которым можно судить о достижении поставленных целей являются: прибыль и затраты на привлечение клиентов.  
Область «клиенты» отвечает за внешние связи предприятия и его отношение с клиентами. Главными целями данной области являются увеличение количества клиентов и повышение узнаваемости автомобильной компании. Используемые в этой области параметрами являются: количество привлеченных клиентов (привлечение нового клиента) и индекс узнаваемости компании.  
Следующая область – «внутренние бизнес-процессы», которые включают: процесс управления производством, процесс размещения рекламы, инновационные процессы. Основными фокусами предприятия являются: повышение качества услуг, повышение рентабельности продаж, контроль деятельности персонала, налаживание связей с поставщиками автомобилей и размещение рекламы. Показателями, которые позволят оценить достижение поставленных целей, являются: отзывы клиентов и затраты на рекламу. 
Четвертая область – обучение и развитие. Очевидно, если перед организацией поставлена долговременная цель, связанная с достижением выдающихся финансовых результатов, то в первую очередь необходимо обучить персонал и развить его профессиональные навыки таким образом, чтобы он был в состоянии организовать внутренние бизнес-процессы, позволяющие производить продукцию и оказывать услуги, которые будут по достоинству оценены клиентами. В качестве целей для этого направления определим следующие: повышение квалификации персонала и обучение сотрудников. Использованы следующие показатели: затраты на обучение новых сотрудников и процент квалифицированных сотрудников. 
На рисунке 1.1 представлена стратегическая карта автомобильной компании с показателями, определяющими критерии достижения целей предприятия. 
 
  
 
Рисунок 1.1 – Стратегическая карта автомобильной компании 
 
Данная стратегическая карта имеет 4 перспективы: финансы, клиенты, внутренние бизнес-процессы, обучение и развитие, на которых декомпозируется стратегия для ее осуществления. 
 
1.3 Описание организационной структуры автомобильной компании 
 
Организационная структура предприятия — одно из ключевых понятий менеджмента, тесно связанное с целями, функциями, процессом управления, работой менеджеров и распределением между ними полномочий. В рамках этой структуры протекает весь управленческий процесс (движение потоков информации и принятие управленческих решений), в котором участвуют менеджеры всех уровней, категорий и профессиональной специализации. 
Структуру можно сравнить с каркасом здания управленческой системы, построенным для того, чтобы все протекающие в ней процессы осуществлялись своевременно и качественно. Организации создают структуру для того, чтобы обеспечивать координацию и контроль деятельности своих подразделений и работников. 
Организационная структура формируется в зависимости от целей деятельности предприятия и необходимых для этого подразделений. Именно подразделения осуществляют функции, которые составляют бизнес-процессы предприятия.  
Автосалон состоит из администрации, бухгалтерии, отдела кадров, отдела маркетинга и менеджмента, отдела продаж, отдела CRM, информационного отдела, АХО, службы безопасности и секретариата. 
Главным на предприятии является генеральный директор. Ему подчиняются заместитель директора по маркетингу и сбыту и заместитель директора по экономике и финансам. Деятельность автосалона поддерживают такие отделы, как: 
–	Отдел продаж. 
Цель коммерческой организации выражена через извлечение прибыли, поэтому ключевым отделом автосалона является отдел продаж. Ключевыми фигурами отдела являются менеджеры отдела продаж, на которых ложится обязанность максимизировать прибыль посредством продажи новых автомобилей. Достаточно важной фигурой отдела является ассистент, в задачи которого входит встреча клиента и ведение необходимого документооборота. 
Основная функция отдела выражена в его названии, однако, это общее понятие включает достаточно большой список бизнес-процессов. Перечислим ключевые: 
–	встреча клиента в автосалоне; 
–	помощь и консультация в выборе автомобиля; 
–	проведение тест - драйва; 
–	заказ на заводе-производителе автомобиля необходимой комплектации; 
–	обслуживание склада автосалона; 
–	отслеживания текущего положения дел по каждому автомобилю; 
–	ведение необходимого документооборота; –  оформление кредита и страхование автомобиля; –  выдача автомобиля клиенту. 
–	Основными документами отдела продаж являются: 
–	годовой план поставок автомобилей; 
–	договор купли-продажи автомобиля; 
–	паспорт транспортного средства; 
–	акт приема-передачи; – транзитные номера; – сервисная книжка. – Отдел маркетинга. 
По дилерскому соглашению основная обязанность в проведении рекламных компаний ложится на плечи компаний-импортеров. Однако, в нашей сети принято решение о проведении рекламных акций, ассоциирующихся с именем нашей компании. Поэтому принято решение организовать отдел маркетинга со следующими функциями: 
–	организация разработки стратегии проведения рекламных акций в средствах массовой информации под лозунгом нашей компании; 
–	участие в подготовке годового плана продаж; 
–	организация выставок и мероприятий по привлечению потенциальных клиентов. 
–	Бухгалтерия. 
Любая коммерческая организация в соответствии с действующим законодательством несёт налоговые обязанности и контролирует финансовое состояние для обеспечения соответствия с таковым. 
Перечислим функции отдела: 
–	контроль и анализ финансового состояния компании; 
–	учет хозяйственных средств; 
–	организация своевременной уплаты налогов и сборов; 
–	прием оплаты клиентом автомобиля; 
–	ведение расчетных операций с компанией-импортером; – взаимодействие с проверяющими организациями. 
–	Отдел CRM (Отдел особых взаимоотношений с клиентами). 
Всё большее число автосалонов открывает у себя подобные отделы, ведь с ростом конкуренции привлечет, убедить клиента купить в автомобиль в своем автосалоне, а также добиться лояльности клиента на будущее становится всё сложнее. Исходя из этого, автосалон не просто должен помнить всех своих клиентов, но и проводить акции, доказывающие такое отношение. Стоит отметить, что данный отдел работает в тесном сотрудничестве с отделом продаж и IT. Основные функции этого отдела: 
–	сопровождение единой базы данных клиентов автосалона; 
–	поздравление 	клиента 	с 	покупкой 	автомобиля 	в 	виде 
поздравительных посылок; 
–	рассылка поздравительных открыток; 
–	приглашение клиентов на особые акции и презентации автосалона; 
–	создание атмосферы особого отношения с клиентом – Отдел кадров. 
Отдел кадров является неотъемлемой частью любой компании. Большинство компаний приходит к выводу, что человеческие ресурсы являются основным капиталом. Основные функции отдела: 
–	обеспечение постоянства кадрового состава за счет поддержания баланса приема и увольнения сотрудников; 
–	планирование карьеры сотрудников; 
–	создание и планирование тарифной сетки; 
–	создание 	планов 	подготовки 	и 	повышение 	квалификации 
сотрудников; 
–	соблюдение норм трудового законодательства; 
–	укрепление трудовой дисциплины и охрана труда; 
–	обеспечение своевременной отчетности; 
–	планирование и создание социальных пакетов организации. 
–	Информационный отдел (IT-отдел). 
Представить работу компании без использования аппаратного и программного компьютерного обеспечения стало практически невозможно. Каждое рабочее место оснащено компьютерами, объединенными в сеть, потому необходимы компетентные люди, способные поддерживать их работоспособность. Основные функции отдела: 
–	создание базы аппаратного и программного обеспечения; 
–	поддержка базы в работоспособном состоянии; 
–	помощь работникам компании в работе с базой обеспечения; 
–	поддержка сайта компании; 
–	сборка и наладка серверов и ПК сотрудников. 
–	Административно-хозяйственный отдел (АХО). 
Поскольку наша организация стремится стать лидером на рынке, необходимо учитывать в процессе работы такие моменты, как идеальная чистота и порядок внутри автосалона. Поэтому важную роль в нашей организации играет административно-хозяйственный отдел.  
Перечислим основные функции отдела: 
–	контроль и обеспечение соблюдения санитарных норм; 
–	закупка необходимого количества средств, необходимых для работы; 
–	ведение отчетности; 
–	взаимодействие с контролирующими организациями. 
–	Служба безопасности. 
Автосалоны нашей сети начинали свой путь с относительно малых масштабов, поэтому наличие такой структуры, как служба безопасности, не требовалось. Были заключены договоры со сторонними фирмами об оказании соответствующих услуг. Однако, по мере развития, встала необходимость открытия в рамках автосалона отдела службы безопасности, несущий куда большую ответственность перед директором автосалона. 
Перечислим основные функции отдела: 
–	охрана зданий, склада, технических средств автосалона; 
–	обеспечение 	режима 	безопасности 	клиентов 	и 	сотрудников 
автосалона; 
–	предотвращение доступа посторонних лиц к объектам и документам, связанным с понятием коммерческой тайны; 
–	локализация и устранение возможных каналов утечки документов, связанных с понятием коммерческой тайны. 
Для осуществления деятельности в автосалоне используются информационные технологии, автоматизирующие основные процессы: административная, коммерческая. автосалон располагает современной материальной базой, включающей вычислительную технику и периферию. 
Администратор автосалона обязан знать: 
–	основы менеджмента и маркетинга; 
–	бизнес-процесс своего автосалона; 
–	технические характеристики автомобилей и дополнительного оборудования; 
–	имена, фамилии, отчества и контактные данные всех должностных лиц и обслуживающих подразделений автосалона; 
–	порядок оформления покупки автомобилей; 
–	методы обработки информации с использованием современных технических средств коммуникации и связи, компьютеров; В обязанности администратора автосалона входит: 
–	ведение учета клиентских групп; 
–	контроль сроков выполнения заказов и информирование клиентов обо всех интересующих их вопросах; 
–	оповещение старшего менеджера-консультанта о приходе посетителей к директору автосалона. В случае необходимости обеспечение клиентов телефонной связью с любым сотрудником автосалона; 
–	контроль и регистрация в ведомостях установленного образца выполнение всех этапов дополнительных работ на проданных автомобилях. 
На рисунке 1.2 представлена организационная структура автомобильной компании. 
 
  
 
Рисунок 1.2– Организационная структура предприятия 
 
Ключевую связывающую роль на предприятии играет исполнительный директор, от его действий зависит курс развития салона. 
 
1.4 Описание процесса «Продажа автомобилей» 
 
Исходя из задания данного курсового проекта, целью моделирования системы является описание ее функциональности для дальнейшего использования созданной модели при разработке информационной модели. 
IDEF0 это метод моделирования, основанный на комбинированной графике и тексте, которые представлены организованным и систематическим способом для достижения понимания, поддержки анализа, обеспечения логики для потенциальных изменений, определения требований или поддержки действий по проектированию и интеграции на уровне систем. Модель IDEF0 состоит из иерархического ряда диаграмм, которые последовательно отображают возрастающие уровни детализации, описывая функции и их интерфейсы в контексте системы. Существует три типа диаграмм: графические, текстовые и глоссарий. Графические диаграммы определяют функции и функциональные отношения с помощью синтаксиса и семантики блоков и стрелок. Текстовая диаграмма и глоссарий предоставляют дополнительную информацию, дополняющую графические диаграммы. 
Компонентами синтаксиса IDEF0 являются блоки и стрелки, правила и диаграммы. Блоки представляют функции, определяемые как деятельность, процесс, операция, действие или преобразование. Стрелки представляют данные или материальные объекты, связанные с функциями. Правила определяют, как следует применять компоненты; диаграммы обеспечивают формат графического и словесного описания моделей. Формат образует основу для управления конфигурацией модели. 
Благодаря диаграмме IDEF-0 можно рассмотреть главный процесс продажи автомобилей и предоставления информации об автомобилях и подпроцессы, сопутствующие главному.  
В ходе детального анализа предметной области была разработана функциональная модель программного обеспечения автосалона. Входными данными является информация о поставщиках, клиент и автомобиль. 
В качестве ресурсов выступают консультант, программное обеспечение, менеджер по продажам. 
Основным процессом является продажа автомобилей и предоставление информации в автосалонах. В соответствии с этим на рисунке 1.3 представлена контекстная диаграмма функциональной модели. 
 
  
 
Рисунок 1.3 – Контекстная диаграмма процесса «Продать автомобиль» 
 
–	Декомпозиция контекстной диаграммы представлена на рисунке 1.4 и включает в себя: 
–	консультацию клиента; 
–	предоставление информации об автомобилях; 
–	оформление заказа. 
 
  
 
Рисунок 1.4 – Декомпозиция контекстной диаграммы процесса 
«Продать автомобиль» 
 
Ниже приведена декомпозиция блока «Предоставить информацию об автомобилях» (Рисунок 1.5).  
 
  
 
Рисунок 1.5 – Декомпозиция блока «Предоставление информации об автомобилях» 
 
Данный блок включает в себя предоставление каталога вариантов для клиентов, автомобилей на тест-драйв и дополнительной информации. 
Ниже приведена декомпозиция блока «Предоставление дополнительной информации» (Рисунок 1.6).  
 
  
 
Рисунок 1.6 – Декомпозиция блока «Предоставление дополнительной информации» 
 
Данный блок включает в себя предоставление информации о марках автомобилей, предоставление информации о годе выпуска и информацию о пробеге. 
Методология IDEF0 нашла широкое признание и применение, в первую очередь, благодаря простой графической нотации, используемой для построения модели. Главными компонентами модели являются диаграммы. На них отображаются функции системы в виде прямоугольников, а также связи между ними и внешней средой посредством стрелок. 
 
 	 











2 ПОСТАНОВКА ЗАДАЧИ НА РАЗРАБОТКУ ПРОГРАММНОГО СРЕДСТВА ДЛЯ АВТОМОБИЛЬНОЙ КОМПАНИИ 
Задачей курсового проекта является создание клиент-серверного программного обеспечения, позволяющего предоставить необходимый функционал для выполнения базовых функций работы с автосалоном, увеличить производительность и быстродействие работников автосалона. 
Деятельность любой компании состоит из десятков рабочих процессов, часть из них повторяется изо дня в день. Письма, заявки, документы, согласования… Автоматизация может улучшить эти процессы и сохранить такой ценный ресурс как время, которое можно потратить на решение более важных задач. В чем сущность автоматизации? Рутинные операции частично или полностью заменяются программным решением и выполняются без участия человека. 
Основной целью автоматизации является повышение качества исполнения процесса. Автоматизированный процесс обладает более стабильными характеристиками, чем процесс, выполняемый в ручном режиме. Во многих случаях автоматизация процессов позволяет повысить производительность, сократить время выполнения процесса, снизить стоимость, увеличить точность и стабильность выполняемых операций. 
На сегодняшний день автоматизация процессов охватила многие отрасли промышленности и сферы деятельности: от производственных процессов, до совершения покупок в магазинах. Вне зависимости от размера и сферы деятельности организации, практически в каждой компании существуют автоматизированные процессы.  
Автомобильные компании не стали исключением и активно используют плоды прогресса в своих деловых интересах. 
С помощью такой процедуры удается сохранить постоянно обновляющуюся связь между всеми подразделениями одного предприятия. Кроме того, можно налаживать ее взаимодействие с информационными сервисами, делать ее более гибкой. 
Так, становится возможным высвобождение человеческих и финансовых ресурсов, повышается производительность труда, стратегия развития действует более эффективно. 
В большинстве фирм не соблюдается четкая последовательность действий. В итоге руководители постоянно загружены, никто не знает, когда будет закончен проект и на каком он этапе сегодня, многие задачи и проверяющие сотрудники дублируются. Получается, что все заняты, а процесс идет крайне медленно. 
А действовать надо иначе. У одного менеджера должно помещаться в ежедневном планере столько проектов, сколько он реально может выполнить. Его цель – контролировать их, отслеживать исполнение, докладывать о результатах. Если на него спустить больше, то все они или некоторые будут сделаны хуже либо медленнее. Но на многих организациях одно и то же задание проверяют сразу несколько людей. 
В бизнес-процессах участвуют все сотрудники, которые любым образом взаимодействуют между собой или с производством. Поэтому часто оптимизация начинается именно с персонала. 
Исходя из поставленного условия разработанный проект по автоматизации работы автомобильного салона позволит предоставить необходимый функционал для выполнения базовых функций работы с автосалоном, увеличить производительность и быстродействие работников автосалона. 
 	  
3 ОПИСАНИЕ МЕТОДА РАНГА 
При решении задач принятия решений приходится встречаться с таким видом неопределенности, обусловленной недостаточной осведомленностью лица принимающего решение (ЛПР) об условиях, в которых будет проводиться операция, и свойствах объектов, участвующих в ней. 
Во всех такого рода случаях неопределенность зависит от неизвестной нам объективной действительности, которую в теории принятия решений называют природой (внешними обстоятельствами). Вопросами принятия решений в условиях неопределенности, обусловленной недостаточным знанием внешних факторов (природы), занимается теория принятия решений. 
Природа в теории статистических решений рассматривается как незаинтересованная инстанция, поведение которой неизвестно, во всяком случае не содержит элемента враждебности и сознательного противодействия достижению цели. Оперирующую сторону в соответствующих ситуациях называют статистиком, а сами ситуации – играми статистика с природой (иначе говоря, играми с природой – внешними обстоятельствами или статистическими играми). 
В играх с природой создание модели начинается с построения платежной матрицы. Это наиболее трудоемкий и ответственный этап подготовки принятия решения, так как ошибки в платежной матрице не могут быть компенсированы никакими вычислительными методами и могут привести к неверному итоговому результату. 
Особенность игры с природой состоит в том, что в ней сознательно действует только один из участников, в большинстве случаев называемый игроком 1 (статистиком). Игрок 2 (природа) сознательно против игрока 1 не действует, а выступает как не имеющий конкретной цели и случайным образом выбирающий очередные «ходы» партнер по игре. 
Допустим имеет место некая операция, в которой активно действующая сторона (игрок 1) может реализовать одну из m возможных стратегий: х1, х2, ¼, xm. Операция должна протекать в условиях недостаточно известной обстановки природы, относительно состояния которой можно сделать п предположений. Возможные состояния природы П1, П2, ¼, Пn будем рассматривать как стратегии природы. Выигрыш aij (проигрыш природы) при каждой паре стратегий (хi, Пj) известен и задан в виде матрицы выигрышей    (табл. 3.1). 
 
Таблица 3.1 – Матрица выигрышей 
хi(Пj 	П1 	П2 	¼ 	Пn 
х1 	а11 	а12 	¼ 	а1n 
х2 	a21 	a22 	¼ 	a2n 
¼ 	¼ 	¼ 	¼ 	¼ 
xm 	am1 	am2 	¼ 	amn 
 
Подходы к принятию решений здесь существенно зависят от возможности или невозможности проводить эксперименты с целью снизить степень неопределенности. 
Неизбежной платой за попытку получить решение в условиях неполной информации о возможных состояниях природы является возможность принятия ошибочных решений. При этом практически ситуации бывают таковы, что отказаться вообще от принятия какого-либо решения бывает невозможно. К тому же решение отказаться от принятия решения также есть решение, и оно может иметь столь же нежелательные последствия, как и другие решения. Единственным выходом из создавшейся ситуации является выработка человеком такой стратегии в отношении принятия решений, которая хотя и не исключает возможность принятия неправильных решений, но сводит к минимуму связанные с этим нежелательные последствия. 
 	  
4 МОДЕЛИ ПРЕДСТАВЛЕНИЯ СИСТЕМЫ ДЛЯ 
АВТОМОБИЛЬНОЙ КОМПАНИИ И ЕЕ ОПИСАНИЕ 
 
UML – унифицированный язык моделирования– это система обозначений, которую можно применять для объектно-ориентированного анализа и проектирования. 
Его можно использовать для визуализации, спецификации, конструирования и документирования программных систем. 
Словарь UML включает три вида строительных блоков: 
– диаграммы; – сущности; – связи. 
 
4.1 Спецификация вариантов использования системы для выбора 
рациональной структуры системы методом экспертных оценок 
 
Диаграмма вариантов использования (сценариев поведения, прецедентов) является исходным концептуальным представлением системы в процессе ее проектирования и разработки. Данная диаграмма состоит из актеров, вариантов использования и отношений между ними. При построении диаграммы могут использоваться также общие элементы нотации: примечания и механизмы расширения.  
Вариант использования обозначается на диаграмме эллипсом, внутри которого содержится его описание, обозначающее выполнение какой-либо операции или действия рисунок. 
Связи 	между 	актерами 	и 	вариантами 	отображаются 	с использованием отношений четырех видов: 
–	ассоциаций; 
–	обобщения; 
–	включения (зависимость со стереотипом «include»); – расширения (зависимость со стереотипом «extend»). 
Диаграмма вариантов использования системы представлена на рисунке 
4.1. 
 
 
Рисунок 4.1 – Диаграмма вариантов использования 
 
На диаграмме видно, что для работы всем пользователям необходимо войти в систему, а для новых пользователей предусмотрена регистрация. 
Администратор выполняет всю административную составляющую работы с программой, в основном работа с поставщиками и контроль за операциями рабочих, клиентов.  
Пользователь же в свою очередь оснащён функциями для добавления желаемых машин, оформления заказа и отслеживание процесса его выполнения. 
У рабочего реализованы инструменты для выбора поставщиков, а так же он оснащен функциями по работе с заказами. 
 
4.2 Описание 	диаграммы 	последовательности 	процесса авторизации 
 
С помощь диаграммы прецедентов (вариантов использования) выявляются основные пользователи системы и задачи, которые данная система должна решать. С помощью диаграммы деятельности мы описываем последовательность действий для каждого прецедента, необходимая для достижения поставленной цели. 
Далее проектируется логическая структура системы с помощью диаграммы классов. На данном этапе выделяются классы, формирующие структуру БД Системы, а также классы, реализующие некий набор операций, способствующий достижению целей в рамках выбранного прецедента. Для описания сложного поведения некоторых объектов (экземпляров класса) составляется диаграмма состояний.     
Таким образом, аналитиками фиксируются такие поведенческие аспекты как алгоритм действий в рамках одного или нескольких прецедентов, необходимый для достижения определённого результата, а также изменение состояния объектов в ходе выполнения приведенных действий.  
Диаграмма последовательности процесса авторизации приведена на рисунке 4.2. 
 
Рисунок 4.2 – Диаграмма последовательности процесса авторизации Диаграмма последовательности процесса авторизации состоит из следующих объектов:  
–	администратор; 
–	окно просмотра клиентов; 
–	клиент; – сервер; 
–	база данных. 
 
4.3 Описание диаграммы состояний 
 
Диаграмма деятельности полезна для описания алгоритма действий, но она не дает представления о поведении определенного объекта в рамках отдельного варианта использования или системы в целом, что необходимо при объектно-ориентированном программировании. 
На сегодняшний день при проектировании сложной системы принято делить ее на части, каждую из которых затем рассматривать отдельно. Таким образом, при объектной декомпозиции система разбивается на объекты или компоненты, которые взаимодействуют друг с другом, обмениваясь сообщениями. Сообщения описывают или представляют собой некоторые события. Получение объектом сообщения активизирует его и побуждает выполнять предписанные его программным кодом действия. 
При данном подходе система становится событийно управляемой, поэтому разработчикам зачастую важно знать, как должен реагировать тот или иной объект на определенные события. Инициаторами событий могут быть как объекты самой системы, так и её внешнее окружение.  
Диаграмма состояния процесса добавления работника изображена на рисунке 4.3. 
 
 
Рисунок 4.3 – Диаграмма состояния процесса добавления работника 
 
В данной диаграмме описан процесс добавления работника. 
 
4.4 Структура хранимых данных рейтингового агентства 
 
IDEF1X является методом для разработки реляционных баз данных и использует условный синтаксис, специально разработанный для удобного построения концептуальной схемы. Концептуальной схемой мы называем универсальное представление структуры данных в рамках коммерческого предприятия, независимое от конечной реализации базы данных и аппаратной платформы. Будучи статическим методом разработки, IDEF1X изначально не предназначен для динамического анализа по принципу "AS IS", тем не менее, он иногда применяется в этом качестве, как альтернатива методу IDEF1. Использование метода IDEF1X наиболее целесообразно для построения логической структуры базы данных после того, как все информационные ресурсы исследованы (скажем с помощью метода IDEF1) и решение о внедрении реляционной базы данных, как части корпоративной информационной системы, было принято. Однако не стоит забывать, что средства моделирования IDEF1X специально разработаны для построения реляционных информационных систем, и если существует необходимость проектирования другой системы, скажем объектно-ориентированной, то лучше избрать другие методы моделирования. 
На рисунке 4.4 представлена модель IDEF1.X данного проекта. 
 
Рисунок 4.4 – Модель IDEF1.X 
 
Все данные хранятся в таблицах, изображенных на рисунке 4.4. 
Таблица car содержит в себе id, название марки, год выпуска, номер, пробег и для кого выполняется заказ. 
Таблица salon_client содержит в себе id, ФИО клиента, телефонный номер, email, номер клиента. 
Таблица salon_worker содержит в себе id, ФИО агента, область работ, специальность, трудовой опыт, номер телефона и номер рабочего. 
Таблица user_role содержит в себе роль авторизации в компании. 
Таблица sale содержит в себе id, продаваемую машину, цену, статус заказа, рабочего занимающегося заказом, дату, диллера, для кого выполняется заказ и комментарий клиента. 
Таблица diller содержит в себе id, имя, область, страну, цену. 
Таблица users содержит в себе id, логин, пароль и роль авторизации. 
Таблица area содержит в себе область работ. 
Отчёты сформированные в ходе выполнения программы сохраняются в формате .txt. 
 
 
4.5 Описание диаграммы классов программного средства для 
выбора рациональной структуры системы методом экспертных оценок 
 
Диаграмма – это графическое представление набора элементов, чаще всего изображенного в виде связного графа вершин (сущностей) и путей (связей). Язык UML включает 13 видов диаграмм, среди которых на первом месте в списке — диаграмма классов, о которой и пойдет речь. Диаграммы классов показывают набор классов, интерфейсов, а также их связи. Диаграммы этого вида чаще всего используются для моделирования объектноориентированных систем. Они предназначены для статического представления 	системы. 
Большинство элементов UML имеют уникальную и прямую графическую нотацию, которая дает визуальное представление наиболее важных аспектов элемента. 
Диаграмма классов, разработанная в данном курсовом проекте представлена на рисунках (рисунок 4.5 и 4.6). 
 
 
Диаграмма классов client содержит классы MainController(admin), 
MainController(user), MainController(worker), Sale, Worker, Car, Client, Diller, 
User, Area, Main, AuthorizationController, RegistrationController, MethodController, PatternDir. 
 
Рисунок 4.6 – Диаграмма классов server 
 
Диаграмма классов server, содержит классы Sale, содержащий поля id, car, area, price, status, worker, requestDate, diller, comment, client. Класс Car содержит поля: id, brand, stateNumber, issueYear, mileage, clientId. Класс Client содержит поля: id, fullName, telephone, email, user. Класс Worker содержит поля: id, fullName, specialty, area, experiance, telephone, user. Класс User содержит поля: id, login, password, role. Класс ClientSocket содержит поля: number, socket, in, out. Класс CarService. Класс UserService. Класс Diller содержит поля: id, name, area, country, price. Класс RequestHandler. Класс Main содержит поля: sessionFactory, clients. Класс AreaService. Класс SaleService. Класс WorkerService. Класс DillerService. Класс ClientService. Класс Area содержит поле: area. 	 
5  ОБОСНОВАНИЕ ВЫБОРА ПРОГРАММНЫХ СРЕДСТВ РАЗРАБОТКИ  
Программный код должен быть написан на объектно-ориентированном языке Java. Java – ЯП от компании Sun microsystems. Изначально разрабатывался как язык для программирования электронных устройств, но позже стал использоваться для написания приложений серверного ПО. Программы на Java – кроссплатформенные, то есть способны работать на любых операционных системах. Некоторые приемущества Java по отношению к другим языкам: 
Одно из основных преимуществ языка Java — независимость от платформы, на которой выполняются программы: один и тот же код можно запускать под управлением операционных систем Windows, Solaris, Linux, Machintosh и др. Это действительно необходимо, когда программы загружаются через Интернет для последующего выполнения под управлением разных операционных систем. 
Другое преимущество заключается в том, что синтаксис языка Java похож на синтаксис языка C++, и программистам, знающим языки С и C++, его изучение не составляет труда.  
Кроме того, Java — полностью объектно-ориентированный язык, даже в большей степени, чем C++. Все сущности в языке Java являются объектами, за исключением немногих основных типов (primitive types), например чисел. Исключена возможность явного выделения и освобождения памяти. 
Введены истинные массивы и запрещена арифметика указателей. 
Исключено множественное наследование. Оно заменено новым понятием — интерфейсом, позаимствованным из языка Objective С. 
Клиент-серверная архитектура наиболее часто используется для создания корпоративных баз данных, в которых информация не только хранится, но и периодически поддается обработке различными методами. Именно база данных является главным элементом любой корпоративной информационной системы, а на сервере располагается ядро этой базы. Так, на сервере происходят наиболее сложные операции, касающиеся ввода, хранения, обработки и модификации данных. Когда пользователь (клиент) обращается к базе данных (серверу), происходит обработка запроса: непосредственно обращение к базе данных и возврат ответа (результата обработки). Результат обработки – это сообщение сети об успешном проведении операции или ошибке. Серверные компьютеры могут обрабатывать одновременно обращение нескольких клиентов к одному и тому же файлу. Такая работа и передача данных по сети позволяет ускорить работу используемых приложений. Основной принцип технологии "клиент-сервер" заключается в разделении функций приложения на три группы: 
–	ввод и отображение данных (взаимодействие с пользователем); 
–	прикладные функции, характерные для данной предметной области; 
–	функции управления ресурсами (файловой системой, базой данных и т.д.). 
–	Поэтому, в любом приложении выделяются следующие компоненты: 
–	компонент представления данных; 
–	прикладной компонент; 
–	компонент управления ресурсом. 
Данная архитектура используется для доступа к различным ресурсам с использованием сетевых технологий: Web-серверы, серверы приложений, серверы баз данных, почтовые серверы, файерволы, прокси-серверы. Разработка клиент-серверных приложений позволяет повысить безопасность, надежность и производительность используемых приложений и сети в целом. Наиболее часто клиент-серверные приложения используются для автоматизации бизнеса.  
Преимущества клиент-серверных систем: 
–	клиент-серверный 	подход 	модульный, 	причем 	серверные программные компоненты компактны и автономны; 
–	сбой сервера не повлияет на остальные компоненты операционной системы; 
–	автономность компонентов делает возможным их выполнение на нескольких процессорах на одном компьютере (симметричная многопроцессорная обработка) или на нескольких компьютерах сети (распределенные вычисления); 
–	обязанность клиента, как правило, – предоставлять пользовательские сервисы и, прежде всего, пользовательский интерфейс, то есть средства для приема, отображения и редактирования данных, введенных пользователем, которые служат основой для запроса серверу.  
Связь между сервером и клиентом в приложении осуществляется при помощи TCP/IP. Также в реализации системы были использованы следующие техники: 
–	разработаны и использованы собственной иерархии, расширение базовых классов, предоставляемых JDK; 
–	реализован паттерн проектирования; 
–	использована инкапсуляция, перегрузка методов, переопределение методов, статические методы, статические поля, обработка исключительных ситуаций. 
Для работы с базой данных был использован Hibenate – одна из наиболее популярных реализаций ORM-модели. Объектно-реляционная модель описывает отношения между программными объектами и записями в БД. Целью Hibernate является освобождение разработчика от значительного объёма сравнительно низкоуровневого программирования при работе в объектно-ориентированных средствах в реляционной базе данных. Разработчик может использовать Hibernate как в процессе проектирования системы классов и таблиц «с нуля», так и для работы с уже существующей базой данных.  
Библиотека не только решает задачу связи классов Java с таблицами базы данных (и типов данных Java с типами данных SQL), но и предоставляет средства для автоматической генерации и обновления набора таблиц, построения запросов и обработки полученных данных. Также может значительно уменьшить время разработки, которое обычно тратится на ручное написание SQL- и JDBC-кода. Hibernate автоматизирует генерацию SQLзапросов и освобождает разработчика от ручной обработки результирующего набора данных и преобразования объектов, максимально облегчая перенос приложения на любые базы данных SQL.  
В качестве основной среды разработки в проекте используется IntelliJ 
IDEA.  В качестве СУБД в курсовом проекте используется MySQL Workbench.   










6  ОПИСАНИЕ АРХИТЕКТУРЫ «КЛИЕНТ-СЕРВЕР»  
Ключевым отличием архитектуры клиент-сервер от архитектуры файлсервер является абстрагирование от внутреннего представления данных (физической схемы данных). Теперь клиентские программы манипулируют данными на уровне логической схемы. Итак, использование архитектуры клиент-сервер позволило создавать надежные (в смысле целостности данных) многопользовательские ИС с централизованной базой данных, независимые от аппаратной (а часто и программной) части сервера БД и поддерживающие графический интерфейс пользователя (ГИП) на клиентских станциях, связанных локальной сетью. Причем издержки на разработку приложений существенно сокращались.  
Независимо от того, как определяется понятие архитектуры "клиентсервер", в основе этого понятия лежит распределенная модель вычислений. В самом общем случае под клиентом и сервером понимаются два взаимодействующих процесса, из которых один является поставщиком некоторого сервиса для другого. Сервер – логический процесс, который обеспечивает некоторый сервис по запросу от клиента. Обычно сервер не только выполняет запрос, но и управляет очередностью запросов, буферами обмена, извещает своих клиентов о выполнении запроса и т. д. Клиент – процесс, который запрашивает обслуживание от сервера. Процесс не является клиентом по каким-то параметрам своей структуры, он является клиентом только по отношению к серверу.  При взаимодействии клиента и сервера инициатором диалога с сервером, как правило, является клиент, сервер сам не инициирует совместную работу. Это не исключает, однако, того, что сервер может извещать клиентов о каких-то зарегистрированных им событиях. Инициирование взаимодействия, запрос на обслуживание, восприятие результатов от сервера, обработка ошибок – это обязанности клиента.  
В любой сети (даже одноранговой), построенной на современных сетевых технологиях, присутствуют элементы клиент-серверного взаимодействия, чаще всего на основе двухзвенной архитектуры. Двухзвенной (two-tier, 2-tier) она называется из-за необходимости распределения трех базовых компонентов между двумя узлами (клиентом и сервером). 
Двухзвенная архитектура используется в клиент-серверных системах, где сервер отвечает на клиентские запросы напрямую и в полном объеме, при этом используя только собственные ресурсы. Т.е. сервер не вызывает сторонние сетевые приложения и не обращается к сторонним ресурсам для выполнения какой-либо части запроса. (Рисунок 3.1) 
  
 
Рисунок 3.1 – Двухзвенная клиент-серверная архитектура 
 
Исходя из перечисленного выше материала можно сделать вывод, что двухзвенная архитектура, используемая в данном проекте, обеспечивает удобную и надежную работу для автомобильной компании. 
 	  
7  ОПИСАНИЕ АЛГОРИТМОВ, РЕАЛИЗУЮЩИХ БИЗНЕС-ЛОГИКУ СЕРВЕРНОЙ ЧАСТИ ПРОЕКТИРУЕМОЙ СИСТЕМЫ 
 
7.1 Схема алгоритма решения задачи статическим методом 
 
Статический метод может быть использован только в том случае, если известны отзывы либо имеется опыт работы с конкретными поставщиками. На рисунке 7.1 представлена схема использования метода. 
 
Рисунок 7.1 – Схема алгоритма статического метода 
 
7.2 Схема алгоритма клиент-серверного взаимодействия 
 
Блок-схема работы сервера показывает общий принцип взаимодействия клиента с сервером: после соединения с клиентом сервер получает от него запросы в виде строк, которые обрабатываются, после чего выполняется набор действий, соответствующий нужному запросу, после чего может посылаться ответ клиенту. Блок-схема данной функции представлена на рисунке 7.1. 
 
  
 
Рисунок 7.2 – Схема алгоритма 
 
7.3 Схема алгоритма предоставления статистической информации 
об автомобилях 
 
Функция в классе, которая отвечает за предоставление статистической графической информации об автомобилях (Рисунок 7.2). 
 
  
 
Рисунок 7.3 – Схема алгоритма 
 
Блок-схема – это схематичное представление процесса, системы или компьютерного алгоритма. Блок-схемы часто применяются в разных сферах деятельности, чтобы документировать, изучать, планировать, совершенствовать и объяснять сложные процессы с помощью простых логичных диаграмм. 
 	  
8  РУКОВОДСТВО ПО РАЗВЕРТЫВАНИЮ СИСТЕМЫ  
 
Рабочей средой данного программного средства для выбора рациональной структуры системы методом экспертных оценок является платформа Java SE [5]. 
Для корректной работы программы на компьютере требуется наличие 32-х разрядной операционной системы Windows 7 и выше. В данном курсовом проекте используется 64-х разрядная операционная система Windows 10. 
Так как программа написана на Java поэтому для запуска среды необходим основной компонент среды Java JDK. А среда для запуска в данном курсовом проекте является InteliJ Idea Ultimate. 
Далее для работы с базой данных в данном курсовом проекте используется MySQL Workbench 8.0 CE. 
Для запуска приложения надо запустить вначале server после надписи «Сервер стартовал» надо запустить client. При первом запуске будет создана база данные, если до этого она не была создана. 
 
  
 
Рисунок 8.1 – Подключение сервера 
 
  
 
Рисунок 8.2 – Подключение клиента 
 
После чего будет открыто главное окно программы рисунок 8.3. 
 
  
 
Рисунок 8.3 – Главное окно программы 
















9  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ  
 
После выполнения действий, описанных в главе 8, пользователю предоставляется выбор действий с данными учётной записи. 
Окно выбора действий с данными учётной записи представлено на рисунке 9.1. 
 
  
 
Рисунок 9.1 – Окно выбора действий с данными учётной записи 
 
При нажатии на кнопку «Регистрация» открывается окно регистрации нового клиента рисунок 9.2. 
 
  
 
Рисунок 9.2 – Окно регистрации 
 
Далее заполняем данные для добавления нового клиента рисунок 9.3. 
 
  
 
Рисунок 9.3 – Добавление нового пользователя 
 
После регистрации входим в учётную запись рисунок 9.4. 
 
  
 
Рисунок 9.4 – Вход в учётную запись 
 
После нажатия кнопки «Вход» происходит переход в меню клиента рисунок 9.5. 
 
  
 
Рисунок 9.5 – Меню клиента 
 
После этого клиент может добавить либо отредактировать машину под свои запросы и оставить заявку на её приобретение. А также увидеть статус своего заказа и занимающегося им сотрудника. Рисунок 9.6 и 9.7. 
 
  
 
Рисунок 9.6 – Добавление машины, редактирование, удаление 
  
 
Рисунок 9.7 – Статус заказа 
 
Так же в приложении можно совершить вход под админом, он имеет функции добавления новых клиентов, новых работников и новых поставщиков рисунок 9.8, 9.9 и 9.10. 
 
   
Рисунок 9.8 – Клиенты 
 
   
Рисунок 9.9 – Работники 
 
   
Рисунок 9.10 – Поставщики 
 
Так же администратор может посмотреть графики в меню работников и клиентов. В меню работников предоставлено количество заказов, а в меню клиентов предоставлены марки и количество заказанных автомобилей. Во вкладке с поставщиками имеется возможность увидеть общее соотношение заказанных автомобилей, предоставленное в виде диаграммы рисунок 9.11, 
9.12, 9.13. 
 
   
Рисунок 9.11 – График работника 
 
   
Рисунок 9.12 – График клиента 
   
Рисунок 9.13 – Диаграмма поставщиков 
 
В приложении можно совершить вход под работником, он имеет доступ к своим заказам, над которыми уже идёт работа, а также к свободным заказам, за которые может взяться рисунок 9.14, 9.15. 
   
Рисунок 9.14 – Заказы в процессе 
 
   
Рисунок 9.15 – Свободные заказы 
 
Далее можно выбрать поставщиков и нажать кнопку «Выбрать диллера», после чего откроется метод рисунок 9.16. 
 
  
Рисунок 9.16 – Метод 
 
Далее работник выставляет рейтинг поставщикам на основе того, с какой вероятностью сделка пройдет положительно. После чего заполняется матрица. 
После заполнения матрицы и нажатия кнопки «Итог» будет показан рекомендованный диллер и получена возможность выставить цену клиенту рисунок 9.17. 
 
   
Рисунок 9.17 – Выставление цены и выбор диллера 
 
В данной главе описано взаимодействие пользователя с программным средством для выбора рациональной структуры системы методом экспертных оценок (на примере рейтингового агентства). Разъяснены способы использования программы при входе в программу под клиентом, агентом и администратором. 
 	 







10  КОНТРОЛЬНЫЙ ПРИМЕР  
 
10.1 Расчет статического метода в условиях неопределенности вручную 
 
Работник заполняет матрицу исходя из опыта работы и отзывов. 
 
Таблица 10.1 – Матрица выигрышей 
Поставщики 
 	Возможные исходы 	Цены 
 
	Благоприятно B1 	Нормально B2 	Ужасно B3 	
П1 	5 	2 	1 	123 
П2 	2 	1 	1 	123 
П3 	1 	1 	3 	123 
 
Определим, какая вероятность преобладает у каждого из поставщиков и присвоим наибольшее значение переменной используя таблицу: П1:(В1=5)>(В2=2)>(В3=1) 
Х1=В1=5 
П2:(В1=2)>(В2=1)>(В3=1) 
Х2=В1=2 
П3:(В1=1)=(В2=1)<(В3=3) 
Х3=В3=3 
 
Так как мы заинтересованы в самом благоприятном исходе, то поставщик с самым высоким показателем В1 для нас является искомым вариантом. Сравним переменную В(у) и вынесем Х с самым маленьким значением у. Если таких будет несколько, их необходимо сохранить для дальнейшего сравнения: 
В выражении (Х1=В1) В(у) минимален. у1=5 В выражении (Х2=В1) В(у) минимален. у2=2. 
В выражении (Х3=В3) В(у) не минимален, так как у нас есть значения меньше. у для него не сохраняем. 
 
Имея 2 переменных с благоприятным исходом необходимо определить, какой же вариант несёт самое надежное предложение путем сравнения переменных: у1=5>у2=2 
 
Соответственно, первый поставщик оказывается самым надежным и рекомендуется для сделки. 
 
10.2 Использование  статического метода в условиях неопределенности в приложении 
 
Можно выбрать поставщиков и нажать кнопку «Выбрать диллера», после чего откроется метод рисунок 10.1. 
 
   
Рисунок 10.1 – Метод 
 
Далее работник выставляет рейтинг поставщикам на основе того, с какой вероятностью сделка пройдет положительно. После чего заполняется матрица. 
После заполнения матрицы и нажатия кнопки «Итог» будет показан рекомендованный диллер и получена возможность выставить цену клиенту рисунок 10.2. 
 
   
Рисунок 10.2 – Выставление цены и выбор диллера 
 
В данном пункте описана работа метода, который рекомендует наиболее привлекательного для сделки диллера. 
 	 


ЗАКЛЮЧЕНИЕ  
 
В наше время высоких технологий очень сложно быть в курсе всех многочисленных новинок в области программного обеспечения. Но ведь именно они могут сделать жизнь человека проще, автоматизируя все возможные процессы. 
В процессе разработки данного ПО было выявлено, что для создания действительно полнофункционального приложения необходимо более детальное рассмотрение данной предметной области. 
Разработанное программное обеспечение было написано на современном языке программирования Java с использованием технологии  «клиент-сервер». 
Использование данной архитектуры способствует явному разделению предоставления нужной информации и интерфейса взаимодействия . 
Клиенту предоставляется информация об информации, хранящейся в базе данных, а также предоставляет весь необходимый интерфейс для работы с данными. 
Использование базы данных в качестве хранилища данных позволяет продуктивно, быстро и эффективно хранить информацию, работать с ней и структурировать. Сервер используемый технологию мультипоточности способен обслуживать одновременно несколько клиентов. 
В результате выполнения данной работы были получены знания о работе с базой данных и непосредственной работе с языком  JAVA.  
На выходе мы получили приложение, которое может частично помочь работникам вести некоторые операции, а также облегчить восприятие информации и доступного интерфейса для получения всего доступного функционала. 
  	 









СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ 
 
[1]	https://ru.wikipedia.org/wiki/UML 
[2]	Петров Ю. А., Петрова Г. И. Терминологический словарьсправочник: экономика, маркетинг, менеджмент. - Микроэкономика: Учебник для вузов. 5-е изд. 
[3]	Токмакова Н.О., Андриянова М.В. МЕНЕДЖМЕНТ-КОНСАЛТИНГ / учебно-методический комплекс. – М. : Изд. центр ЕАОИ, 2009. – 271 с. 
[4]	Автомобильный транспорт [Электронный ресурс]. – Электронные данные. – Режим доступа: https://works.doklad.ru/view/znIF2D8HezY.html [5] Автомобиль в жизни современного человека [Электронный ресурс]. 
– 	Электронные 	данные. 	– 	Режим 	доступа: 
http://siroedenie.vargin.ru/st003/avtomobil-v-zhizni-sovrjemjennogochjelovjeka.html 
[6]	101 Бизнес план [Электронный ресурс]. – Электронные данные. – 
Режим 	доступа: 	http://101biznesplan.ru/spravochnikpredprinimatelya/dolzhnostnye-obyazannosti/ 
[7]	Роль автомобиля в современной жизни [Электронный ресурс]. – 
Электронные 	данные. 	– 	Режим 	доступа: 
http://kolesomag.ru/autonews/automobili_two/498-rol-avtomobilya-vsovremennoy-zhizni.html 
[8]	Принцип работы клиент-серверных приложений [Электронный ресурс]. – Электронные данные. – Режим доступа: 
http://fb.ru/article/101006/klient-servernaya-arhitektura-osobennostivzaimodeystviya 
[9]	Б. Эккель. Философия Java [4-e издание]. – "Питер" · 2015 г., 962 с. 
[10]	Г. Шилдт. Java. Полное руководство 8-е издание – "Вильямс", 2015 г., 1376 с. 
[11]	Хабрахабр [Электронный ресурс]. – Электронные данные. – Режим доступа: https://habrahabr.ru 
[12]	Методология IDEF0 – Электронные данные – Режим доступа: 
https://itteach.ru/bpwin/metodologiya-idef0 
[13]	Б. Шварц. MySQL по максимуму. – Питер , 2018г. 864 с. 
 
ПРИЛОЖЕНИЕ А (ОБЯЗАТЕЛЬНОЕ) 
 
Скрипт базы данных 
 
create database salon CHARACTER SET utf8 COLLATE utf8_unicode_ci; 
 
use salon; 
 
create table user_role( 
name varchar(40) primary key 
); 
 
insert into user_role values('Админ'), ('Работник'), ('Клиент'); 
 
create table work_area( 
area varchar(100) not null primary key 
); 
 
insert into work_area(area) values('Минск'), ('Брест'); 
 
create table users( 
id int primary key auto_increment, login varchar(40) not null, pass varchar(40) not null, role varchar(40) not null, 
    FOREIGN KEY (role) REFERENCES user_role(name) ON DELETE CASCADE on 
update cascade 
); 
 
insert into users values(1, 'admin', 'admin', 'Админ'); insert into users values(2, 'master', 'master', 'Работник'); 
 
create table salon_worker( id int primary key auto_increment, full_name varchar(50) not null, specialty varchar(50) not null, area varchar(100) not null, 
    FOREIGN KEY (area) REFERENCES work_area(area) ON DELETE CASCADE on 
update cascade, experience float, telephone char(13) not null, 
user int not null, 
 
    
 	 
Продолжение приложения А 
 
 FOREIGN KEY (user) REFERENCES users(id) ON DELETE CASCADE on update 
cascade 
); 
 
insert into salon_worker values(1, 'Иванов Иван Иванович', 'Босс', 'Минск', 10.5, '+375299234526', 2); 
 
create table salon_client( id int primary key auto_increment, full_name varchar(50) not null, telephone char(13) not null, email varchar(40), user int not null, 
    FOREIGN KEY (user) REFERENCES users(id) ON DELETE CASCADE on update cascade 
); 
 
create table car( id int primary key auto_increment, car_brand varchar(40) not null, state_number char(9) not null, issue_year char(4), mileage varchar(40) not null, client int not null, 
    FOREIGN KEY (client) REFERENCES salon_client(id) ON DELETE CASCADE on update cascade 
); 
 
create table diller( 
id int primary key auto_increment, name varchar(30) not null, area varchar(100) not null, 
    FOREIGN KEY (area) REFERENCES work_area(area) ON DELETE CASCADE on 
update cascade, producing_country varchar(50) not null, 
price float not null 
); 
 
insert into diller values(1, 'Минск Кристалл', 'Минск', 'Беларусь', 1500); 
 
 
create table sale( 
id int primary key auto_increment, 
Продолжение приложения А 
 
car int not null, 
    FOREIGN KEY (car) REFERENCES car(id) ON DELETE CASCADE on update 
cascade, area varchar(100) not null, 
    FOREIGN KEY (area) REFERENCES work_area(area) ON DELETE CASCADE on 
update cascade, price float, 
status varchar(30) not null, 
worker int, 
    FOREIGN KEY (worker) REFERENCES salon_worker(id) ON DELETE CASCADE 
on update cascade, request_date char(10) not null, diller int, 
    FOREIGN KEY (diller) REFERENCES diller(id) ON DELETE CASCADE on update cascade, client int, 
    FOREIGN KEY (client) REFERENCES salon_client(id) ON DELETE CASCADE on update cascade, comment varchar(300) not null 
);  


















ПРИЛОЖЕНИЕ Б (ОБЯЗАТЕЛЬНОЕ) 
ЛИСТИНГ КОДА С КОМЕНТАРИЯМИ 
 
Серверная часть,Main 
 
package main; 
 
import javafx.application.Application; import javafx.fxml.FXML; import javafx.fxml.FXMLLoader; import javafx.scene.Parent; import javafx.scene.Scene; import javafx.scene.image.Image; import javafx.stage.Stage; 
import main.controllers.AuthorizationController; 
 import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.Socket; import java.time.LocalDate; import java.util.Date; 
 
public class Main extends Application{ 
 
    static public Socket connection;     static public ObjectOutputStream output;     static public ObjectInputStream input; 
 
    public static void main(String[] args){         launch(args); 
    } 
 
    @Override 
    public void start(Stage primaryStage) throws Exception {         try { 
            connection = new Socket("127.0.0.1", 4041); 
            output = new ObjectOutputStream(connection.getOutputStream());             input = new ObjectInputStream(connection.getInputStream());         } catch (IOException e) { 
            e.printStackTrace(); 
        } 
        FXMLLoader loader = new 
FXMLLoader(Main.class.getResource("/main/windows/fxml/authorization.fxml")); 
        Parent root = loader.load();         Scene scene = new Scene(root);         primaryStage.setScene(scene);         primaryStage.setTitle("Салон");         primaryStage.show(); 
    } 
      public static void sendData(Object message) {         try { 
            output.flush(); 
            output.writeObject(message); 
 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
    } 
 } 
 
Серверная часть,worker 
 
package main.controllers.worker; 
 
import com.google.gson.Gson; 
import com.google.gson.reflect.TypeToken; import javafx.collections.FXCollections; import javafx.collections.ObservableList; import javafx.fxml.FXML; import javafx.fxml.FXMLLoader; import javafx.scene.Parent; import javafx.scene.Scene; import javafx.scene.control.*; 
 
import javafx.scene.control.cell.PropertyValueFactory; import javafx.scene.image.Image; import javafx.stage.Stage; import main.Main; import main.entity.Diller; import main.entity.Sale; import main.entity.Car; import main.entity.Worker; 
 import java.io.IOException; import java.lang.reflect.Type; import java.util.ArrayList; 
 import static main.Main.input; import static main.Main.sendData; 
 
public class MainController { 
 
    Worker thisWorker; 
    ArrayList<Diller> dillerArrayList;  
    @FXML 
    private TitledPane freeOrdersPane; 
 
    @FXML 
    private TableView<Sale> freeOrders; 
 
    @FXML 
    private TableColumn<Sale, Integer> freeOrderCarId;  
    @FXML 
    private TableColumn<Sale, Float> freeOrderPrice; 
 
    @FXML 
    private TableColumn<Sale, String> freeOrderStatus;  
    @FXML 
    private TableColumn<Sale, String> freeOrderDate; 
 
    @FXML 
    private TableColumn<Sale, String> freeOrderComment;  
    @FXML 
    private TextField viewFreeCarBrand; 
 
    @FXML 
    private TextField viewFreeCarNumber; 
 
    @FXML 
    private TextField viewFreeCarIssueYear; 
 
    @FXML 
    private TextField viewFreeCarMileage; 
 
    @FXML 
    private ListView<String> freeDetails; 
 
    @FXML 
    private ListView<String> selectedDetails; 
 
    @FXML 
    private TitledPane requestsPane; 
 
    @FXML 
    private TableView<Sale> backingTable; 
 
    @FXML 
    private TableColumn<Sale, Integer> backingCarId; 
 
    @FXML 
    private TableColumn<Sale, Float> backingPrice; 
 
    @FXML 
    private TableColumn<Sale, String> backingStatus;  
    @FXML 
    private TableColumn<Sale, String> backingRequestDate;  
    @FXML 
    private TableColumn<Sale, String> backingComment; 
 
    @FXML 
    private TextField viewCarBrand; 
 
    @FXML 
    private TextField viewCarNumber;  
    @FXML 
    private TextField viewCarIssueYear;  
    @FXML 
    private ComboBox<String> orderStatus; 
 
    @FXML 
    private TextField viewCarMileage; 
 
    @FXML 
    private Spinner<Double> priceSpinner; 
 
    @FXML 
    private Label workerFullName; 
 
    @FXML 
    private Button exitButton; 
 
    @FXML 
    void exit() throws IOException { 
        exitButton.getScene().getWindow().hide(); 
        Stage stage = new Stage(); 
        FXMLLoader loader = new 
FXMLLoader(Main.class.getResource("/main/windows/fxml/authorization.fxml")); 
        Parent root = loader.load();         Scene scene = new Scene(root);         stage.setScene(scene);         stage.setTitle("Салон");         stage.show(); 
    } 
 
    @FXML 
    void getBackingInfo() throws IOException, ClassNotFoundException {         if(freeOrders.getSelectionModel().getSelectedItem()!=null){             sendData("Информация о машине"); 
            
sendData(String.valueOf(freeOrders.getSelectionModel().getSelectedItem().getC ar())); 
            String carInfo = (String) input.readObject();             Car car = new Gson().fromJson(carInfo, Car.class);             viewFreeCarBrand.setText(car.getBrand());             viewFreeCarIssueYear.setText(car.getIssueYear());             viewFreeCarMileage.setText(car.getMileage());             viewFreeCarNumber.setText(car.getStateNumber()); 
        } 
    } 
 
    @FXML 
    void getMyBackingInfo() throws IOException, ClassNotFoundException {         if(backingTable.getSelectionModel().getSelectedItem()!=null){             sendData("Информация о машине"); 
            
sendData(String.valueOf(backingTable.getSelectionModel().getSelectedItem().ge tCar())); 
            String carInfo = (String) input.readObject();             Car car = new Gson().fromJson(carInfo, Car.class);             viewCarBrand.setText(car.getBrand());             viewCarIssueYear.setText(car.getIssueYear());             viewCarMileage.setText(car.getMileage());             viewCarNumber.setText(car.getStateNumber()); 
             priceSpinner.getValueFactory().setValue( 
                    (double) 
backingTable.getSelectionModel().getSelectedItem().getPrice()); 
            
orderStatus.setValue(backingTable.getSelectionModel().getSelectedItem().getSt atus()); 
        } 
    } 
 
method() throws IOException { 
        if (freeOrders.getSelectionModel().getSelectedItem()!=null) { 
            if (selectedDetails.getItems().size() == 3) { 
                Diller firstDiller = null, secondDiller = null, thirdDiller = null; 
                for (Diller diller : dillerArrayList) {                     if 
(selectedDetails.getItems().get(0).split(",")[0].equals(diller.getName()) && 
                            
selectedDetails.getItems().get(0).split(",")[1].trim().equals(diller.getCount ry())) { 
                        firstDiller = diller; 
                    } 
                } 
                for (Diller diller : dillerArrayList) {                     if 
(selectedDetails.getItems().get(1).split(",")[0].equals(diller.getName()) && 
                            
selectedDetails.getItems().get(1).split(",")[1].trim().equals(diller.getCount ry())) { 
                        secondDiller = diller; 
                    } 
                } 
                for (Diller diller : dillerArrayList) {                     if 
(selectedDetails.getItems().get(2).split(",")[0].equals(diller.getName()) && 
                            
selectedDetails.getItems().get(2).split(",")[1].trim().equals(diller.getCount ry())) { 
                        thirdDiller = diller; 
                    }                 } 
 
                Stage stage = new Stage(); 
                FXMLLoader loader = new 
FXMLLoader(Main.class.getResource("/main/windows/fxml/worker/method.fxml")); 
                Parent root = loader.load(); 
                Scene scene = new Scene(root);                 stage.setScene(scene);                 stage.setTitle("Салон"); 
                MethodController methodController = loader.getController();                 methodController.initialize(firstDiller, secondDiller, thirdDiller, freeOrders.getSelectionModel().getSelectedItem(),                         thisWorker, this);                 stage.show(); 
            } else { 
                Alert alert = new Alert(Alert.AlertType.ERROR);                 alert.setTitle("Ошибка"); 
                alert.setHeaderText("Выберите 3 диллера");                 alert.showAndWait(); 
            } 
        }else { 
            Alert alert = new Alert(Alert.AlertType.ERROR);             alert.setTitle("Ошибка"); 
            alert.setHeaderText("Выберите заказ"); 
            alert.showAndWait(); 
        } 
    } 
refuse() throws IOException, ClassNotFoundException { 
        if(backingTable.getSelectionModel().getSelectedItem()!=null){ 
            
if(!backingTable.getSelectionModel().getSelectedItem().getStatus().equals("Го тов")) { 
                Sale sale = 
backingTable.getSelectionModel().getSelectedItem();                 sale.setStatus("Ожидает");                 sale.setPrice(0);                 sale.setWorker(1);                 sale.setDiller(1); 
                sendData("Изменение заказа");                 sendData(new Gson().toJson(sale));                 initialize(); 
            }             else{ 
                Alert alert = new Alert(Alert.AlertType.ERROR);                 alert.setTitle("Ошибка"); 
                alert.setHeaderText("Вы не можете отказаться от заказа, который уже готов"); 
                alert.showAndWait(); 
            } 
        }else{ 
            Alert alert = new Alert(Alert.AlertType.ERROR);             alert.setTitle("Ошибка"); 
            alert.setHeaderText("Выберите заказ");             alert.showAndWait(); 
        } 
    } 
 
    @FXML 
    void saveChanges() throws IOException, ClassNotFoundException {         if(backingTable.getSelectionModel().getSelectedItem()!=null){ 
            
if(!backingTable.getSelectionModel().getSelectedItem().getStatus().equals("Го тов")) { 
                Sale sale = 
backingTable.getSelectionModel().getSelectedItem();                 sale.setStatus(orderStatus.getValue()); 
                
sale.setPrice(Float.parseFloat(String.valueOf(priceSpinner.getValue())));                 sendData("Изменение заказа");                 sendData(new Gson().toJson(sale));                 initialize(); 
            }else{ 
                Alert alert = new Alert(Alert.AlertType.ERROR);                 alert.setTitle("Ошибка"); 
                alert.setHeaderText("Вы не можете изменить заказ, который уже готов"); 
                alert.showAndWait(); 
            } 
        }else{ 
            Alert alert = new Alert(Alert.AlertType.ERROR);             alert.setTitle("Ошибка"); 
            alert.setHeaderText("Выберите заказ"); 
            alert.showAndWait(); 
        } 
    } 
selectDetail() { 
        if(freeDetails.getSelectionModel().getSelectedItem()!=null) {             if (selectedDetails.getItems().size() < 3) { 
                
selectedDetails.getItems().add(freeDetails.getSelectionModel().getSelectedIte m()); 
                
freeDetails.getItems().remove(freeDetails.getSelectionModel().getSelectedItem
()); 
            } 
        } 
    } 
 
    @FXML 
    void unselectDetail() { 
        if(selectedDetails.getSelectionModel().getSelectedItem()!=null) { 
            
freeDetails.getItems().add(selectedDetails.getSelectionModel().getSelectedIte m());             
selectedDetails.getItems().remove(selectedDetails.getSelectionModel().getSele ctedItem()); 
        } 
    } 
 
    @FXML 
    void initialize() throws IOException, ClassNotFoundException {         freeDetails.getItems().clear();         selectedDetails.getItems().clear(); 
        if(thisWorker == null){ 
            String workerInfo = (String) Main.input.readObject();             thisWorker = new Gson().fromJson(workerInfo, Worker.class);         } 
         workerFullName.setText(thisWorker.getFullName() + ", специалист в области '" + thisWorker.getArea() + "'"); 
         sendData("Свободные заказы");         sendData(thisWorker.getArea()); 
        String backingsInfo = (String) Main.input.readObject(); 
        Type type = new TypeToken<ArrayList<Sale>>(){}.getType(); 
        ArrayList<Sale> saleArrayList = new Gson().fromJson(backingsInfo, type); 
        ObservableList<Sale> saleObservableList = FXCollections.observableArrayList(saleArrayList);         freeOrderCarId.setCellValueFactory(new PropertyValueFactory<>("car")); 
        freeOrderPrice.setCellValueFactory(new PropertyValueFactory<>("price")); 
        freeOrderStatus.setCellValueFactory(new PropertyValueFactory<>("status")); 
        freeOrderDate.setCellValueFactory(new PropertyValueFactory<>("requestDate")); 
        freeOrderComment.setCellValueFactory(new PropertyValueFactory<>("comment")); 
        freeOrders.setItems(saleObservableList); 
 
        sendData("Заказы работника"); 
 
        sendData(thisWorker.getId()); 
        backingsInfo = (String) Main.input.readObject(); 
        type = new TypeToken<ArrayList<Sale>>(){}.getType();         saleArrayList = new Gson().fromJson(backingsInfo, type);         saleObservableList = 
FXCollections.observableArrayList(saleArrayList); 
        backingCarId.setCellValueFactory(new PropertyValueFactory<>("car"));         backingPrice.setCellValueFactory(new PropertyValueFactory<>("price")); 
        backingStatus.setCellValueFactory(new PropertyValueFactory<>("status")); 
        backingRequestDate.setCellValueFactory(new PropertyValueFactory<>("requestDate"));         backingComment.setCellValueFactory(new PropertyValueFactory<>("comment")); 
        backingTable.setItems(saleObservableList); 
         sendData("Диллеры области");         sendData(thisWorker.getArea()); 
        String detailsInfo = (String) Main.input.readObject();         type = new TypeToken<ArrayList<Diller>>(){}.getType();         dillerArrayList = new Gson().fromJson(detailsInfo, type); 
 
        for(Diller diller : dillerArrayList){ 
            freeDetails.getItems().add(diller.getName() + ", " + diller.getCountry()); 
        } 
 
        ObservableList<Double> prices = 
FXCollections.observableArrayList(100.0, 200.0, 300.0, 400.0, 500.0, 
                600.0, 700.0, 800.0, 900.0, 1000.0);         priceSpinner.setValueFactory(new 
SpinnerValueFactory.ListSpinnerValueFactory<>(prices)); 
 
        ArrayList<String> statuses = new ArrayList<>();         statuses.add("Обрабатывается");         statuses.add("Работа приостановлена"); 
        statuses.add("Готов"); 
        ObservableList<String> statusesObservableList = FXCollections.observableList(statuses); 
        orderStatus.setItems(statusesObservableList); 
    } 
} 
 

